from fastapi import FastAPI, UploadFile, File, Form, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from typing import Dict, List
import base64
import time
import io
from PIL import Image, ImageDraw, ImageFont
import json

app = FastAPI(title="PDF Extraction API (Mock Version)")

# Enable CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

def create_mock_annotated_image(page_num: int, model_name: str) -> str:
    """Create a mock annotated image"""
    # Create a simple mock PDF page image
    img = Image.new('RGB', (800, 1000), color='white')
    draw = ImageDraw.Draw(img)
    
    # Draw some mock content blocks
    draw.rectangle([50, 50, 750, 150], outline='red', width=2)
    draw.text((60, 60), f"Mock Title - {model_name} Model", fill='black')
    
    draw.rectangle([50, 200, 750, 350], outline='blue', width=2)
    draw.text((60, 210), f"Mock Paragraph Content\nPage {page_num + 1}\nProcessed by {model_name}", fill='black')
    
    draw.rectangle([50, 400, 750, 600], outline='green', width=2)
    draw.text((60, 410), "Mock Table Content\n| Column 1 | Column 2 |\n|----------|----------|", fill='black')
    
    # Convert to base64
    buffered = io.BytesIO()
    img.save(buffered, format="PNG")
    img_str = base64.b64encode(buffered.getvalue()).decode()
    return f"data:image/png;base64,{img_str}"

def generate_mock_markdown(model_name: str, pages: int) -> str:
    """Generate mock markdown content"""
    content = []
    for i in range(pages):
        page_content = f"""# Page {i + 1} ({model_name})

## Mock Title Section
This is mock content generated by the {model_name} model for page {i + 1}.

### Mock Subsection
Here's some sample paragraph text that would typically be extracted from a PDF document. The {model_name} model has processed this content and converted it to markdown format.

#### Mock Table
| Feature | {model_name} |
|---------|-------------|
| Speed | {"Fast" if model_name == "surya" else "Medium" if model_name == "docling" else "Slow"} |
| Accuracy | {"High" if model_name == "docling" else "Medium"} |
| Tables | {"Good" if model_name == "mineru" else "Fair"} |

**Mock List:**
- Item 1 extracted by {model_name}
- Item 2 with some details
- Item 3 showing capability

> This is a mock blockquote that demonstrates text extraction capabilities.

"""
        content.append(page_content)
    
    return "\n\n".join(content)

@app.post("/api/extract")
async def extract_pdf(
    file: UploadFile = File(...),
    models: str = Form("surya,docling,mineru"),
):
    if not file.filename or not file.filename.lower().endswith(".pdf"):
        raise HTTPException(status_code=400, detail="Please upload a PDF file.")
    
    # Read file content (we won't actually process it, just get the size)
    pdf_bytes = await file.read()
    if not pdf_bytes:
        raise HTTPException(status_code=400, detail="Empty file.")
    
    # Mock processing - simulate different pages based on file size
    mock_pages = min(max(1, len(pdf_bytes) // 50000), 5)  # 1-5 pages based on file size
    
    selected_models = [m.strip().lower() for m in models.split(",") if m.strip()]
    if not selected_models:
        selected_models = ["surya", "docling", "mineru"]
    
    results = {}
    
    for model_name in selected_models:
        # Simulate processing time
        start_time = time.time()
        
        # Different models have different "processing times"
        processing_times = {"surya": 0.8, "docling": 1.2, "mineru": 1.5}
        time.sleep(processing_times.get(model_name, 1.0))
        
        elapsed_ms = (time.time() - start_time) * 1000
        
        # Generate mock data
        markdown_content = generate_mock_markdown(model_name, mock_pages)
        annotated_images = []
        
        for page_num in range(mock_pages):
            img_data = create_mock_annotated_image(page_num, model_name)
            annotated_images.append(img_data)
        
        # Mock metadata with realistic variations
        char_count = len(markdown_content)
        word_count = len(markdown_content.split())
        
        # Different models detect different numbers of elements
        element_variations = {
            "surya": {"titles": 3, "headers": 8, "paragraphs": 12, "tables": 2, "figures": 1},
            "docling": {"titles": 4, "headers": 10, "paragraphs": 15, "tables": 3, "figures": 2},
            "mineru": {"titles": 2, "headers": 6, "paragraphs": 10, "tables": 4, "figures": 1}
        }
        
        elements = element_variations.get(model_name, {"titles": 3, "headers": 8, "paragraphs": 12, "tables": 2, "figures": 1})
        
        results[model_name] = {
            "text_markdown": markdown_content,
            "annotated_images": annotated_images,
            "meta": {
                "time_ms": round(elapsed_ms, 2),
                "block_count": sum(elements.values()) + 5,  # Add some base blocks
                "ocr_box_count": sum(elements.values()) * 2,
                "char_count": char_count,
                "word_count": word_count,
                "element_counts": elements,
                "confidence": 0.85 + (hash(model_name) % 10) / 100  # Mock confidence 0.85-0.94
            }
        }
    
    return {
        "pages": mock_pages,
        "models": results
    }

@app.get("/")
async def root():
    return {"message": "PDF Extraction API (Mock Version) - Ready!"}

@app.get("/health")
async def health():
    return {"status": "healthy", "version": "mock-1.0.0"}

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)